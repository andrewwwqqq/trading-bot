const puppeteer = require('puppeteer')

const delay = ms => new Promise(resolve => setTimeout(resolve, ms))
const API_URL = 'http://localhost:3000' // –£–∫–∞–∂–∏ URL —Å–µ—Ä–≤–µ—Ä–∞

;(async () => {
	const urls = [
		'https://www.tradingview.com/chart/?symbol=BINANCE:AVAXUSDT&interval=7',
		// 'https://www.tradingview.com/chart/?symbol=BINANCE:ADAUSDT&interval=7',
	]

	const currencies = ['AVAXUSDT', 'ADAUSDT']

	for (let index = 0; index < urls.length; index++) {
		const url = urls[index]

		const browser = await puppeteer.launch({
			headless: false,
			args: ['--start-maximized'],
		})
		const page = await browser.newPage()

		// –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º cookies –¥–ª—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏
		const cookies = [
			{
				name: 'sessionid',
				value: 'eictbpvvxxg8ocqvyr7jjhk205lfknnl',
				domain: '.tradingview.com',
			},
			{
				name: 'sessionid_sign',
				value: 'v3:0x18KSxoHi5nwUyFAvWWt+hAyMzuj5QXKFULA8bWB7s=',
				domain: '.tradingview.com',
			},
			{
				name: 'tv_ecuid',
				value: 'd637097c-674b-4b0e-a680-1f035be2d549',
				domain: '.tradingview.com',
			},
		]
		await page.setCookie(...cookies)

		console.log('‚úÖ –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è —á–µ—Ä–µ–∑ cookies —É—Å–ø–µ—à–Ω–∞!')

		const [width, height] = [1920, 1080]
		await page.setViewport({ width, height })

		await page.goto(url, {
			waitUntil: 'networkidle2',
			timeout: 0,
		})

		// üîç –ò—â–µ–º –∫–Ω–æ–ø–∫—É Object Tree and Data Window –æ–¥–∏–Ω —Ä–∞–∑ –∏ –ø–æ–ª—É—á–∞–µ–º –µ—ë –∞—Ç—Ä–∏–±—É—Ç aria-pressed
		const objectTreeButtonData = await page.evaluate(() => {
			const xpath = "//button[@aria-label='Object Tree and Data Window']"
			const result = document.evaluate(
				xpath,
				document,
				null,
				XPathResult.FIRST_ORDERED_NODE_TYPE,
				null
			)
			const objectTreeButton = result.singleNodeValue

			if (objectTreeButton) {
				return {
					found: true,
					ariaPressed: objectTreeButton.getAttribute('aria-pressed'),
					xpath: xpath, // –°–æ—Ö—Ä–∞–Ω—è–µ–º XPath, —á—Ç–æ–±—ã –ø–æ—Ç–æ–º –∫–ª–∏–∫–Ω—É—Ç—å
				}
			}
			return { found: false }
		})

		// –µ—Å–ª–∏ –∫–Ω–æ–ø–∫–∞ Object Tree and Data Window –Ω–∞–π–¥–µ–Ω–∞
		if (objectTreeButtonData.found) {
			console.log('‚úÖ –ö–Ω–æ–ø–∫–∞ "Object Tree and Data Window" –Ω–∞–π–¥–µ–Ω–∞!')

			// –ø—Ä–æ–≤–µ—Ä—è–µ–º –∞–∫—Ç–∏–≤–Ω–∞ –ª–∏ Object Tree and Data Window
			if (objectTreeButtonData.ariaPressed === 'false') {
				console.log('‚ö° –ö–Ω–æ–ø–∫–∞ –Ω–µ –∞–∫—Ç–∏–≤–Ω–∞, –∫–ª–∏–∫–∞–µ–º...')

				// –ö–ª–∏–∫–∞–µ–º –ø–æ –∫–Ω–æ–ø–∫–µ —á–µ—Ä–µ–∑ XPath
				await page.evaluate(xpath => {
					const result = document.evaluate(
						xpath,
						document,
						null,
						XPathResult.FIRST_ORDERED_NODE_TYPE,
						null
					)
					const objectTreeButton = result.singleNodeValue
					if (objectTreeButton) objectTreeButton.click()
				}, objectTreeButtonData.xpath)

				console.log('‚úÖ –ö–Ω–æ–ø–∫–∞ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–∞!')
			} else {
				console.log('‚úÖ –ö–Ω–æ–ø–∫–∞ —É–∂–µ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–∞!')
			}
		} else {
			console.error('‚ùå –ö–Ω–æ–ø–∫–∞ "Object Tree and Data Window" –Ω–µ –Ω–∞–π–¥–µ–Ω–∞!')
		}
		// üîç –ò—â–µ–º –∫–Ω–æ–ø–∫—É "Data Window" –æ–¥–∏–Ω —Ä–∞–∑ –∏ –ø–æ–ª—É—á–∞–µ–º –µ—ë –∞—Ç—Ä–∏–±—É—Ç aria-selected
		const dataWindowButtonData = await page.evaluate(() => {
			const xpath = "//button[@id='data-window']"
			const result = document.evaluate(
				xpath,
				document,
				null,
				XPathResult.FIRST_ORDERED_NODE_TYPE,
				null
			)
			const dataWindowButton = result.singleNodeValue

			if (dataWindowButton) {
				return {
					found: true,
					ariaSelected: dataWindowButton.getAttribute('aria-selected'),
					xpath: xpath, // –°–æ—Ö—Ä–∞–Ω—è–µ–º XPath, —á—Ç–æ–±—ã –ø–æ—Ç–æ–º –∫–ª–∏–∫–Ω—É—Ç—å
				}
			}
			return { found: false }
		})

		// –µ—Å–ª–∏ –∫–Ω–æ–ø–∫–∞ Data Window –Ω–∞–π–¥–µ–Ω–∞
		if (dataWindowButtonData.found) {
			console.log('‚úÖ –ö–Ω–æ–ø–∫–∞ "Data Window" –Ω–∞–π–¥–µ–Ω–∞!')

			// –ø—Ä–æ–≤–µ—Ä—è–µ–º –∞–∫—Ç–∏–≤–Ω–∞ –ª–∏ –∫–Ω–æ–ø–∫–∞ Data Window
			if (dataWindowButtonData.ariaSelected === 'false') {
				console.log('‚ö° –ö–Ω–æ–ø–∫–∞ "Data Window" –Ω–µ –∞–∫—Ç–∏–≤–Ω–∞, –∫–ª–∏–∫–∞–µ–º...')

				// –ö–ª–∏–∫–∞–µ–º –ø–æ –∫–Ω–æ–ø–∫–µ —á–µ—Ä–µ–∑ XPath
				await page.evaluate(xpath => {
					const result = document.evaluate(
						xpath,
						document,
						null,
						XPathResult.FIRST_ORDERED_NODE_TYPE,
						null
					)
					const dataWindowButton = result.singleNodeValue
					if (dataWindowButton) dataWindowButton.click()
				}, dataWindowButtonData.xpath)

				console.log('‚úÖ –ö–Ω–æ–ø–∫–∞ "Data Window" –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–∞!')
			} else {
				console.log('‚úÖ –ö–Ω–æ–ø–∫–∞ "Data Window" —É–∂–µ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–∞!')
			}
		} else {
			console.error('‚ùå –ö–Ω–æ–ø–∫–∞ "Data Window" –Ω–µ –Ω–∞–π–¥–µ–Ω–∞!')
		}

		// üîç –∏—â–µ–º –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä "TL 1.0" –Ω–∞ –ø–∞–Ω–µ–ª–∏
		const tl1Indicator = await page.evaluate(() => {
			const xpath = "//span[contains(text(), 'TL 1.0')]"
			const result = document.evaluate(
				xpath,
				document,
				null,
				XPathResult.FIRST_ORDERED_NODE_TYPE,
				null
			)
			return { found: result.singleNodeValue !== null }
		})

		// –µ—Å—Ç—å –ª–∏ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä "TL 1.0" –Ω–∞ –ø–∞–Ω–µ–ª–∏
		if (tl1Indicator.found) {
			console.log('‚úÖ –°–ø–∞–Ω —Å —Ç–µ–∫—Å—Ç–æ–º "TL 1.0" –Ω–∞–π–¥–µ–Ω!')
		} else {
			console.log('‚ùå –°–ø–∞–Ω —Å —Ç–µ–∫—Å—Ç–æ–º "TL 1.0" –Ω–µ –Ω–∞–π–¥–µ–Ω!')

			// üîç –ò—â–µ–º –∫–Ω–æ–ø–∫—É –¥–ª—è –≤—ã–±–æ—Ä–∞ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–≤
			const chooseIndicatorButtonData = await page.evaluate(() => {
				const xpath =
					"//button[@aria-label='Indicators, metrics, and strategies']"
				const result = document.evaluate(
					xpath,
					document,
					null,
					XPathResult.FIRST_ORDERED_NODE_TYPE,
					null
				)
				const chooseIndicatorButton = result.singleNodeValue
				return {
					found: chooseIndicatorButton !== null,
					xpath: xpath,
				}
			})

			// –µ—Å–ª–∏ –Ω–∞—à–ª–∏ –∫–Ω–æ–ø–∫—É –¥–ª—è –≤—ã–±–æ—Ä–∞ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–≤
			if (chooseIndicatorButtonData.found) {
				console.log('‚úÖ –ö–Ω–æ–ø–∫–∞ "Indicators, metrics, and strategies" –Ω–∞–π–¥–µ–Ω–∞!')

				// –ö–ª–∏–∫–∞–µ–º –ø–æ –∫–Ω–æ–ø–∫–µ —á–µ—Ä–µ–∑ XPath
				await page.evaluate(xpath => {
					const result = document.evaluate(
						xpath,
						document,
						null,
						XPathResult.FIRST_ORDERED_NODE_TYPE,
						null
					)
					const chooseIndicatorButton = result.singleNodeValue
					if (chooseIndicatorButton) chooseIndicatorButton.click()
				}, chooseIndicatorButtonData.xpath)

				console.log(
					'‚úÖ –ö–Ω–æ–ø–∫–∞ "Indicators, metrics, and strategies" –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–∞!'
				)

				// üîç –ë–µ—Å–∫–æ–Ω–µ—á–Ω—ã–π —Ü–∏–∫–ª –ø–æ–∏—Å–∫–∞ –≤–∫–ª–∞–¥–∫–∏ "Invite-only"
				while (true) {
					console.log('‚è≥ –ò—â–µ–º —ç–ª–µ–º–µ–Ω—Ç "Invite-only"...')

					const inviteOnlyData = await page.evaluate(() => {
						const xpath = "//span[contains(text(), 'Invite-only')]"
						const result = document.evaluate(
							xpath,
							document,
							null,
							XPathResult.FIRST_ORDERED_NODE_TYPE,
							null
						)
						const inviteOnlyText = result.singleNodeValue

						if (inviteOnlyText) {
							const inviteOnlyTab = inviteOnlyText.closest('div')
							if (inviteOnlyTab) {
								inviteOnlyTab.click()
								return { found: true }
							}
						}
						return { found: false }
					})

					if (inviteOnlyData.found) {
						console.log('‚úÖ –≠–ª–µ–º–µ–Ω—Ç "Invite-only" –Ω–∞–π–¥–µ–Ω –∏ –∫–ª–∏–∫–Ω—É—Ç!')
						break
					}

					console.log(
						'‚ùå –≠–ª–µ–º–µ–Ω—Ç "Invite-only" –Ω–µ –Ω–∞–π–¥–µ–Ω, –ø–æ–≤—Ç–æ—Ä—è–µ–º —á–µ—Ä–µ–∑ 2 —Å–µ–∫—É–Ω–¥—ã...'
					)
					await delay(2000)
				}

				// üîç –ü—Ä–æ–≤–µ—Ä—è–µ–º –∏ –∫–ª–∏–∫–∞–µ–º –ø–æ "Indicator - TL 1.0"
				const indicatorData = await page.evaluate(() => {
					const xpath = "//div[@data-title='Indicator - TL 1.0']"
					const result = document.evaluate(
						xpath,
						document,
						null,
						XPathResult.FIRST_ORDERED_NODE_TYPE,
						null
					)
					const indicatorElement = result.singleNodeValue

					if (indicatorElement) {
						// –ò—â–µ–º span —Å —Ç–µ–∫—Å—Ç–æ–º "Indicator - TL 1.0" —á–µ—Ä–µ–∑ XPath
						const indicatorElementTextXpath =
							".//span[text()='Indicator - TL 1.0']" // –ò—Å–ø–æ–ª—å–∑—É–µ–º –ª–æ–∫–∞–ª—å–Ω—ã–π XPath –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ div
						const indicatorElementTextResult = document.evaluate(
							indicatorElementTextXpath,
							indicatorElement,
							null,
							XPathResult.FIRST_ORDERED_NODE_TYPE,
							null
						)
						const indicatorElementText =
							indicatorElementTextResult.singleNodeValue

						// –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–∞–π–¥–µ–Ω –ª–∏ –Ω—É–∂–Ω—ã–π span
						const isIndicatorElementTextCorrect = indicatorElementText !== null

						// –ò—â–µ–º —Å—Å—ã–ª–∫—É <a> —Å href="/u/igoraa500/" —á–µ—Ä–µ–∑ XPath
						const indicatorElementLinkXpath = ".//a[@href='/u/igoraa500/']" // –ò—Å–ø–æ–ª—å–∑—É–µ–º –ª–æ–∫–∞–ª—å–Ω—ã–π XPath –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ div
						const indicatorElementLinkResult = document.evaluate(
							indicatorElementLinkXpath,
							indicatorElement,
							null,
							XPathResult.FIRST_ORDERED_NODE_TYPE,
							null
						)
						const indicatorElementLink =
							indicatorElementLinkResult.singleNodeValue

						const isIndicatorElementLinkCorrect = indicatorElementLink !== null

						if (
							isIndicatorElementTextCorrect &&
							isIndicatorElementLinkCorrect
						) {
							indicatorElement.click() // –ö–ª–∏–∫–∞–µ–º –ø–æ div, –µ—Å–ª–∏ –æ–±–∞ —É—Å–ª–æ–≤–∏—è –≤—ã–ø–æ–ª–Ω–µ–Ω—ã
							return { found: true }
						}
					}

					return { found: false }
				})

				if (indicatorData.found) {
					console.log('‚úÖ –≠–ª–µ–º–µ–Ω—Ç "Indicator - TL 1.0" –Ω–∞–π–¥–µ–Ω –∏ –∫–ª–∏–∫–Ω—É—Ç!')

					// üîç –ò—â–µ–º –∫–Ω–æ–ø–∫—É –∑–∞–∫—Ä—ã—Ç–∏—è –≤—ã–±–æ—Ä–∞ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–≤
					const closeIndicatorsButtonData = await page.evaluate(() => {
						const xpath = "//button[@data-name='close']"
						const result = document.evaluate(
							xpath,
							document,
							null,
							XPathResult.FIRST_ORDERED_NODE_TYPE,
							null
						)
						const closeIndicatorsButton = result.singleNodeValue

						if (closeIndicatorsButton) {
							closeIndicatorsButton.click()
							return { found: true }
						}
						return { found: false }
					})

					if (closeIndicatorsButtonData.found) {
						console.log('‚úÖ –ö–Ω–æ–ø–∫–∞ "Close" –Ω–∞–∂–∞—Ç–∞.')
					} else {
						console.log('‚ùå –ö–Ω–æ–ø–∫–∞ "Close" –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.')
					}
				} else {
					console.log('‚ùå –≠–ª–µ–º–µ–Ω—Ç "Indicator - TL 1.0" –Ω–µ –Ω–∞–π–¥–µ–Ω.')
				}
			} else {
				console.error(
					'‚ùå –ö–Ω–æ–ø–∫–∞ "Indicators, metrics, and strategies" –Ω–µ –Ω–∞–π–¥–µ–Ω–∞!'
				)
			}
		}

		// –û–∂–∏–¥–∞–µ–º—ã–µ —Ü–≤–µ—Ç–∞ –ø–æ –∏–Ω–¥–µ–∫—Å–∞–º
		const expectedColors = [
			'rgb(255, 82, 82)', // 1, 5
			'rgb(255, 152, 0)', // 2, 6
			'rgb(76, 175, 80)', // 3, 7
			'rgb(49, 27, 146)', // 4, 8
		]

		// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∑–Ω–∞—á–µ–Ω–∏–π –≤—Å–µ—Ö span –≤–Ω—É—Ç—Ä–∏ —Ä–æ–¥–∏—Ç–µ–ª—å—Å–∫–∏—Ö div —Å "Shapes"
		const getShapesData = async () => {
			return await page.evaluate(expectedColors => {
				const xpath = "//div[contains(text(), 'Shapes')]"
				const result = document.evaluate(
					xpath,
					document,
					null,
					XPathResult.ORDERED_NODE_SNAPSHOT_TYPE,
					null
				)

				const shapesData = []

				for (
					let i = 0;
					i < result.snapshotLength && shapesData.length < 8;
					i++
				) {
					const shapesDataParent = result.snapshotItem(i)
					if (!shapesDataParent || !shapesDataParent.parentElement) continue

					const shapesDataValue =
						shapesDataParent.parentElement.querySelector('span')
					if (shapesDataValue) {
						const color = shapesDataValue.style.color
						const text = shapesDataValue.innerText.trim()
						const expectedColor = expectedColors[i % 4] // –¶–≤–µ—Ç –ø–æ —à–∞–±–ª–æ–Ω—É
						const isValid = color === expectedColor // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏—è

						shapesData.push({ color, text, isValid })
					}
				}

				return shapesData
			}, expectedColors)
		}

		// –§—É–Ω–∫—Ü–∏—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏—è —Ü–≤–µ—Ç–æ–≤
		const validateColors = shapesData => {
			let isAllElementsValid = true

			shapesData.forEach((shapeData, index) => {
				if (shapeData.isValid) {
					console.log(
						`‚úÖ –≠–ª–µ–º–µ–Ω—Ç ${index + 1} —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç: ${
							shapeData.color
						}, —Ç–µ–∫—Å—Ç: "${shapeData.text}"`
					)
				} else {
					isAllElementsValid = false

					console.error(
						`‚ùå –û—à–∏–±–∫–∞! –≠–ª–µ–º–µ–Ω—Ç ${index + 1}: –æ–∂–∏–¥–∞–ª—Å—è —Ü–≤–µ—Ç ${
							expectedColors[index % 4]
						}, –Ω–æ –ø–æ–ª—É—á–µ–Ω ${shapeData.color}`
					)
				}
			})

			return isAllElementsValid
		}

		const sendTlData = async (previousShapesData, index) => {
			const tl = previousShapesData.map(previousShapeData => {
				const { isValid, ...newPreviousShapeData } = previousShapeData // –ò–∑–≤–ª–µ–∫–∞–µ–º –≤—Å–µ —Å–≤–æ–π—Å—Ç–≤–∞, –∫—Ä–æ–º–µ isValid
				return newPreviousShapeData
			})

			const now = new Date()
			const timestamp = `${now.getFullYear()}-${(now.getMonth() + 1)
				.toString()
				.padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')} ${now
				.getHours()
				.toString()
				.padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:${now
				.getSeconds()
				.toString()
				.padStart(2, '0')}`

			const data = {
				currencie: currencies[index],
				tl,
				timestamp,
			}

			try {
				const response = await fetch(`${API_URL}/data`, {
					method: 'POST',
					headers: {
						'Content-Type': 'application/json',
					},
					body: JSON.stringify(data),
				})

				const result = await response.json()
				console.log('‚úÖ –û—Ç–≤–µ—Ç –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞:', result)

				return result
			} catch (error) {
				console.error('‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –¥–∞–Ω–Ω—ã—Ö:', error)
			}
		}

		// üî• –ü–µ—Ä–≤–∏—á–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —Ü–≤–µ—Ç–æ–≤
		let previousShapesData = await getShapesData()
		console.log('üìä –ù–∞—á–∞–ª—å–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è span:', previousShapesData)
		const isValidColorOfElements = validateColors(previousShapesData)

		if (isValidColorOfElements) {
			await sendTlData(previousShapesData, index)
		}

		// üîÑ –ü—Ä–æ–≤–µ—Ä—è–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏—è –∫–∞–∂–¥—ã–µ 20 –º—Å
		setInterval(async () => {
			const currentShapesData = await getShapesData()

			// –ü—Ä–æ–≤–µ—Ä—è–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏—è
			let hasChanges = false

			currentShapesData.forEach((currentShapeData, index) => {
				if (
					currentShapeData.color !== previousShapesData[index]?.color ||
					currentShapeData.text !== previousShapesData[index]?.text
				) {
					hasChanges = true
				}
			})

			// –ï—Å–ª–∏ –±—ã–ª–∏ –∏–∑–º–µ–Ω–µ–Ω–∏—è, –ø—Ä–æ–≤–µ—Ä—è–µ–º —Ü–≤–µ—Ç–∞
			if (hasChanges) {
				console.log('tl –∏–∑–º–µ–Ω–∏–ª—Å—è: ')
				console.log(currentShapesData)
				const isValidColorOfElements = validateColors(currentShapesData)
				previousShapesData = currentShapesData

				if (isValidColorOfElements) {
					await sendTlData(previousShapesData, index)
				}
			}
		}, 20)

		await delay(3000)
	}
})()
